async downloadExcel(paginationDto: PaginationDto) {
    const {
        page = 1,
        limit = 10,
        order = 'desc',
        sort = 'id',
        filter = '[]',
    } = paginationDto;

    // Construcción del filtro y cálculo de offset
    const objectFilter = await this.globalFunctions.getObjectFilterGrid(
        sort,
        order,
        page,
        limit,
        filter,
    );
    const offset = await this.globalFunctions.getOffsetByPage(page, limit);

    // Consulta de registros con relaciones
    const records = await this.prisma.record.findMany({
        select: {
            id: true,
            user: {
                select: {
                    fullname: true,
                },
            },
            project: {
                select: {
                    name: true,
                },
            },
            category: {
                select: {
                    name: true,
                },
            },
            area: true,
            type: true,
            worker_fullname: true,
            worker_id_number: true,
            description: true,
            actions: true,
            suggestions: true,
            boss_title: true,
            boss_signature: true,
            boss_fullname: true,
            photo_flag: true,
            url_front: true,
            url_back: true,
            completed: true,
            created_at: true,
            updated_at: true,
            latitude: true,
            longitude: true,
            record_risk: {
                select: {
                    risk: {
                        select: {
                            name: true,
                        },
                    },
                },
            },
        },
        where: {
            deleted_at: null,
            AND: objectFilter.contains,
        },
        skip: offset,
        take: objectFilter.cant,
        orderBy: objectFilter.order,
    });

    if (!records.length) {
        throw new BadRequestException('No se encontraron registros para exportar.');
    }

    // Crear el libro y la hoja
    const book = new Workbook();
    const sheet = book.addWorksheet('Registros');

    // Crear encabezados de la tabla
    sheet.addRow([
        'ID',
        'Usuario',
        'Proyecto',
        'Categoría',
        'Área',
        'Tipo',
        'Nombre del Trabajador',
        'DNI del Trabajador',
        'Descripción',
        'Acciones',
        'Sugerencias',
        'Título del Jefe',
        'Firma del Jefe',
        'Nombre del Jefe',
        'Foto (flag)',
        'URL Frontal',
        'URL Trasera',
        'Completado',
        'Fecha de Creación',
        'Última Actualización',
        'Latitud',
        'Longitud',
        'Riesgos Asociados',
    ]);

    // Añadir los datos de los registros a la tabla
    records.forEach((record) => {
        sheet.addRow([
            record.id,
            record.user?.fullname || '',
            record.project?.name || '',
            record.category?.name || '',
            record.area || '',
            record.type || '',
            record.worker_fullname || '',
            record.worker_id_number || '',
            record.description || '',
            record.actions || '',
            record.suggestions || '',
            record.boss_title || '',
            record.boss_signature || '',
            record.boss_fullname || '',
            record.photo_flag === 1 ? 'Sí' : 'No',
            record.url_front || '',
            record.url_back || '',
            record.completed ? record.completed.toISOString() : '',
            record.created_at.toISOString(),
            record.updated_at ? record.updated_at.toISOString() : '',
            record.latitude || '',
            record.longitude || '',
            record.record_risk.map((risk) => risk.risk.name).join(', ') || '',
        ]);
    });

    // Ajustar ancho de columnas
    sheet.columns.forEach((column) => {
        column.width = 20;
    });

    // Generar el archivo temporal
    const file = await new Promise<string>((resolve, reject) => {
        tmp.file(
            {
                discardDescriptor: true,
                prefix: 'Registros',
                postfix: '.xlsx',
                mode: parseInt('0600', 8),
            },
            async (err, file) => {
                if (err) {
                    return reject(new BadRequestException(err));
                }
                await book.xlsx.writeFile(file);
                resolve(file);
            },
        );
    });

    return file;
}